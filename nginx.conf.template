# A single worker is enough for load balancing and reverse proxing.
# While disk I/O can block an nginx worker, it's possible to enable
# async read and send for static files.
#
worker_processes 1;

# The limit on the maximum number of open files for worker processes.
# This overrides the OS limit for the user the workers run as:
#   ulimit -a | grep 'open files'
#
# This value must be equal or higher than the worker_connections value.
#
worker_rlimit_nofile 4096;

# Log to stdout.
# Use the stdout of init on Docker to get the logs to the log drain.
#
error_log /proc/1/fd/1 warn;

pid /var/run/nginx.pid;


events {
  # The maximum number of simultaneous connections that can be
  # opened by a worker process. This limit is shared between
  # client connections and upstream connections.
  #
  worker_connections 4096;

  # "on" if nginx worker_processes > 1
  #
  accept_mutex off;
}


http {
  server_tokens off;

  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  log_format  main  '[nginx] '
                    'remote_addr=[$remote_addr] time=[$time_local] duration=[$request_time] '
                    'status=[$status] cache=[$upstream_cache_status] upstream_status=[$upstream_status] '
                    'method=[$request_method] path=[$request_uri] size=[$body_bytes_sent] '
                    '"$remote_user" "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';

  # Log to stdout.
  # Use the stdout of init on Docker to get the logs to the log drain.
  #
  access_log /proc/1/fd/1 main;

  tcp_nodelay on;

  keepalive_timeout 20s; # default 75s

  gzip on;
  gzip_http_version 1.0;
  gzip_proxied any;
  gzip_vary on;
  gzip_min_length 500;
  gzip_disable "MSIE [1-6]\.";
  gzip_types text/plain text/xml text/css
             text/comma-separated-values
             text/javascript application/x-javascript
             application/javascript application/json
             application/atom+xml;

  # According to the HTTP standard, headers with underscores are perfectly valid.
  # However, nginx defaults to dropping headers containing underscores, as they
  # might introduce ambiguities when mapping headers to CGI variables.
  #
  underscores_in_headers on;

  map $http_x_forwarded_proto $thescheme {
      default $scheme;
      https https;
  }

  # Cache
  proxy_cache_path /tmp/nginx-cache levels=1:2 keys_zone=static-cache:25m max_size=100m inactive=60m use_temp_path=off;
  map $sent_http_content_type $expires {
    "text/html"                 5m; # set this to your needs
    "text/html; charset=utf-8"  5m; # set this to your needs
    default                     1h; # set this to your needs
  }

  server {
    listen <NGINX_PORT> deferred; # default 80

    client_body_buffer_size <NGINX_CLIENT_BODY_BUFFER_SIZE>; # default 8k
    client_max_body_size <NGINX_CLIENT_MAX_BODY_SIZE>; # default 5M

    # Caching static files
    location ~* \.(?:ico|gif|jpe?g|png|woff2?|eot|otf|ttf|svg|js|css)$ {
      expires               $expires;
      add_header            X-Cache-Status  $upstream_cache_status;
      proxy_cache           static-cache;
      proxy_cache_bypass    $arg_nocache;   # probably better to change this
      proxy_cache_valid     200 302         1h;  # set this to your needs
      proxy_cache_valid     404             1m;   # set this to your needs
      proxy_cache_lock      on;
      proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504;
      proxy_cache_key       $uri$is_args$args;
      proxy_ignore_headers  Cache-Control;

      # Use external config
      include proxy.conf;
    }

    location / {
      # Use external config
      include proxy.conf;
    }
  }

  server {
    listen <NGINX_STATUS_PORT>;
    server_name localhost;

    access_log off;
    allow <NGINX_STATUS_ALLOW_FROM>;
    deny all;

    location /nginx_status {
      stub_status;
      # ensures the version information can be retrieved
      server_tokens on;
    }
  }
}
